# Auditoria Técnica — Nexus QuantumI2A2

## 1. Sumário da análise técnica
- **Arquitetura:** o repositório expõe um SPA React/Vite (`App.tsx`, `components/`, `hooks/`, `services/`) que se comunica com um BFF Node/Express (`backend/server.js`) via HTTP e WebSocket. O backend orquestra um pipeline multiagente com filas BullMQ (cada agente reside em `backend/agents/*.js`) e armazena estado no Redis (`backend/services/redisClient.js`), artefatos no disco (`backend/services/storage.js`) e vetores no Weaviate (`backend/services/weaviateClient.js`). O frontend usa `config.ts` para derivar URLs do BFF e mantém memória contextual/localStorage em `contexts/contextMemory.ts`, enquanto serviços como `services/geminiService.ts` providenciam chamadas à proxy Gemini.
- **Dependências chaves:** `@google/genai`, `bullmq`, `redis`, `weaviate-ts-client`, `ws`, `tesseract.js`, `sharp`, `pdf-parse` e várias bibliotecas para parsing (`xlsx`, `mammoth`, `jszip`). Todas estão divididas entre `package.json` raiz (aplicação SPA) e `backend/package.json` (BFF/agentes). O uso de promessas, WebSocket, filas e contextos compartilhados sustenta a coerência entre camadas.
- **Integração e camadas:** o frontend envia arquivos via `/api/jobs` e consome estado em tempo real via WebSocket (`backend/server.js:135-220`). Os agentes reagem a `eventBus` e manipulam o estado do pipeline/resultado através de `redis`, garantindo que cada etapa (extração, validação, auditoria, classificação, IA, indexação) receba dados encadeados declarados em `backend/pipeline.yaml`. O backend também expõe chat RAG, exportações e conciliação por meio das rotas em `backend/routes/*.js`.
- **Coesão lógica:** o conjunto de serviços auxiliares (e.g., `services/artifactUtils.js`, `services/extractor.js`, `services/tools.js`) mantém responsabilidades delimitadas, embora seja necessário reforçar o encapsulamento entre o Orquestrador (`server.js`) e os agentes (p. ex., gerenciamento de payloads).
- **Observabilidade e estabilidade:** métricas básicas (`backend/services/metrics.js`) e logs estruturados acompanham requests e WebSockets, mas ainda é necessário reforçar alertas/telemetria para filas e tempo de execução dos agentes. Limpeza de arquivos não é bloqueante (`storage.js`) e existe desligamento gracioso no servidor (`backend/server.js:300-340`).

## 2. Problemas identificados e causas
| Problema | Causa raiz | Impacto | Severidade |
| --- | --- | --- | --- |
| O orquestrador dispara a próxima etapa duas vezes | `eventBus.on('task:completed')` chama `startTask(jobId, nextTask, payload)` e em seguida `startTask(jobId, nextTask, nextPayload)` sem esperar o primeiro terminar (`backend/server.js:242-255`). | Cada etapa do pipeline pode ser enfileirada e executada duas vezes, gerando duplicação de trabalho, sobrecarga no Redis/queues e resultados inconsistentes (o mesmo job pode emitir dois estados “completado” para a mesma etapa). | Alta |
| Testes unitários/componente backend não iniciam (ReferenceError: DOMMatrix) | `pdf-parse` (importado em `backend/services/extractor.js:1-40`) referencia APIs DOM disponíveis apenas no browser; Jest carrega o módulo ao iniciar os testes (e isso ainda ocorre mesmo com mocks). | A suíte completa (`backend/tests/*.test.js`) não executa, bloqueando CI; equipes não conseguem validar mudanças no pipeline. | Alta |
| Ausência de fallback do pipeline ao chamar ferramentas | O flux de `analysisAgent` aciona `eventBus.emit('tool:run')`, mas o Orquestrador não confirma que o resultado já foi reencaminhado antes de continuar, o que pode deixar o job em “aguardando” se `tool:completed` for perdido ou falhar silenciosamente. | Jobs ficam presos na etapa `analysis`, gerando timeout/perda de estado. | Média |

## 3. Sugestões de correção e otimização
1. **Corrigir o salto duplicado do pipeline** — remova a primeira chamada `startTask` e passe apenas `nextPayload` para a próxima etapa, garantindo que cada tarefa seja enfileirada uma vez. Isso reduz a carga em BullMQ e evita discrepâncias nos indicadores de pipeline (`backend/server.js:242-255`). Prioridade: crítica.
2. **Polifilar ou mockar DOMMatrix nos testes** — configure um `jest.setup.js` global que define `global.DOMMatrix = class {}; global.DOMPoint = class {};` antes de importar `backend/services/extractor.js`, ou extraia a dependência de `pdf-parse` para um módulo lazy/mocked (`backend/services/extractor.js:1-40`). Isso desbloqueia `npm test` e impede falhas nas pipelines CI. Prioridade: alta.
3. **Fortalecer o orquestrador de ferramentas** — valide que o evento `tool:run` retorna um success/failure para o agent (adicionar timeout/retries), para não travar a etapa `analysis` quando uma ferramenta falha silenciosamente (`backend/agents/analysisAgent.js:1-120`). Prioridade: média.
4. **Instrumentar filas e workers** — exponha métricas de latência/concurrency (por exemplo, contadores para cada fila do `backend/services/queue.js` e `eventBus`) e registre timestamps em `job.result`, ajudando a identificar gargalos e variações de desempenho. Prioridade: média.
5. **Padronizar configuração local** — documente/automatize `.env.example` com chaves `GEMINI_API_KEY`, `REDIS_URL`, `WEAVIATE_HOST` e instruções para rodar o stack (`docker-compose.yml` + `start-dev.sh`) para garantir coerência entre equipes. Prioridade: média/baixa.

## 4. Resultados dos testes realizados / roteiro recomendado
- **Comando executado:** `cd backend && npm test`
  - Resultado: **falha em todas as suítes**. O erro “ReferenceError: DOMMatrix is not defined” originate em `backend/services/extractor.js:1-40` quando `pdf-parse` (via pdf.js) tenta referência a APIs DOM. É necessário polifil ou mock.
- **Próximos passos recomendados para validar a base:**
  1. Adicione um arquivo `backend/jest.setup.js` (referenciado em `package.json` com `"setupFiles": ["./jest.setup.js"]`) que define `global.DOMMatrix`, `global.DOMPoint`, e outros objetos browser-like antes de carregar `pdf-parse`.
  2. Reexecute `cd backend && npm test` no ambiente limpo com `GEMINI_API_KEY`, `REDIS_URL`, `WEAVIATE_HOST` (mesmo que sejam mocks) e com `redis-server`/`weaviate` subindo por `docker-compose`.
  3. Para o frontend, execute `npm run build` na raiz para garantir que o Vite embale todos os componentes e fail early caso existam imports inválidos.
  4. Automatize a verificação de lint (`npm run lint` no backend e `npm run lint` adicional se for ajustado no frontend) e inclua testes de smoke (upload e chat via API) contra um backend em execução pelo `docker-compose` para garantir coerência.

## 5. Recomendações de manutenção contínua e aprimoramento futuro
- **Monitoramento contínuo:** exporte as métricas internas (`metrics.formatPrometheus()`) para um endpoint real (Prometheus + Grafana) e monitore latências de filas, uso de tokens do Gemini e taxa de falhas em `eventBus`.
- **Revisão periódica de dependências pesadas:** `pdf-parse`, `sharp`, `tesseract.js` e `@google/genai` são potenciais vetores de consumo de memória. Estabeleça uma cadência mensal para atualizar e revisar breaking changes, especialmente para o Gemini SDK.
- **Auditoria de segurança e privacidade:** garanta que o `GEMINI_API_KEY` não seja exposto em logs; traceamento atual (logs `console.log`) deve evoluir para um logger com níveis/rotas estruturadas. Centralize a rotação de chaves e crie alertas ao detectar erros críticos do `handleError` global.
- **Documentação viva do pipeline:** mantenha um diagrama atualizado (mermaid fum) e a `pipeline.yaml` sincronizada com o código dos agentes; isso aumenta a confiabilidade ao adicionar novos passos ou ferramentas e evita a duplicação detectada no `task:completed`.
- **Testes e QA contínuos:** integre testes end-to-end (upload + chat + exportação) no CI, preferencialmente usando containers que simulam Redis/Weaviate/Gemini (via mocks). Isso garante que o sistema “rode liso” como esperado após cada alteração.
